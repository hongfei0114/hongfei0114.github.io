---
layout:     post
title:      
subtitle:   
date:       2020-04-xx
author:     hongfei
header-img: img/post-bg-debug.png
catalog: true
tags:
    - mysql
    


---



# MySQL原理审理理解

## MySQL体系结构



##  MySQ语句执行过程

###  MySQL查询过程

- mysql执行一个查询的过程，执行的步骤包括：
  - 客户端发送一条查询给服务器；
  - 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。
  - 服务器段进行SQL解析、预处理，在优化器生成对应的执行计划；
  - mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询。
  - 将结果返回给客户端

![image-20200416004748001](https://tva1.sinaimg.cn/large/007S8ZIlly1gduxn32zhdj30le0ifgol.jpg)



###  MySQL server 和 client通讯

> mysql客户端和服务器之间的通讯协议是“半双工”的，这意味着，在任何一个时刻，要么由服务器向
>
> 客户端发送数据，要么由客户端向服务器发送数据，这两个动作不能同时发生。这种协议让mysql通信简
>
> 单快速，但也限制了mysql。一个明显的限制是，这意味着没办法进行流量限制。一旦一端开始发生消息，
>
> 另一端要接收完整个消息才能响应他。



###  查询状态

- 对于mysql连接，任何时刻都有一个状态，该状态表示了mysql当前正在做什么。使用`show full processlist`命令查看当前状态。
- 在一个查询生命周期中，状态会变化很多次
- 相关状态
  - sleep：**线程正在等待客户端发送新的请求；**
  - query：线程正在执行查询或者正在将结果发送给客户端；
  - locked：在mysql服务器层，该线程正在等待表锁。
  - analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划；
  - copying to tmp table：线程在执行查询，并且将其结果集复制到一个临时表中，这种状态一般要么是做group by操作，要么是文件排序操作，或者union操作。如果这个状态后面还有on disk标记，那表示mysql正在将一个内存临时表放到磁盘上。
  - sorting Result：线程正在对结果集进行排序。
  - sending data：线程可能在多个状态间传送数据，或者在生成结果集，或者在想客户端返回数据。



###  查询缓存

- 在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果，这种情况下查询就会进入下一阶段的处理
- 如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前mysql会检查一次用户权限。这仍然是无须解析查询SQL语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题，mysql会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行。



###  查询优化处理

查询的生命周期的下一步是将一个SQL转换成一个执行计划，mysql在依照这个执行计划和存储引擎进行交互。这包含多个子阶段：**解析SQL、预处理、优化SQL执行计划**。这个过程中任何错误都可能终止查询。

- 语法解析器和预处理：首先mysql通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。
  - mysql解析器将使用mysql语法规则验证和解析查询；
  - 预处理器则根据一些mysql规则进一步检查解析树是否合法。

- 查询优化器：当语法树被认为是合法的了，并且由优化器将其转化成执行计划。
  - 一条查询可以有很多种执行方式，最后都返回相同的结果。
  - 优化器的作用就是找到这其中最好的执行计划。

- 执行计划：mysql不会生成查询字节码来执行查询，mysql生成查询的一棵指令树，然后通过存储引擎执行

完成这棵指令树并返回结果。最终的执行计划包含了重构查询的全部信息。



###  查询执行引擎

在解析和优化阶段，mysql将生成查询对应的执行计划，mysql的查询执行引擎则根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和很多其他的关系型数据库那样对应的字节码。mysql简单的根据执行计划给出的指令逐步执行。在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成。为了执行查询，mysql只需要重复执行计划中的各个操作，直到完成所有的数据查询。

###  返回结果给客户端

- 查询执行的最后一个阶段是将结果返回给客户端。
  - 即使查询不需要返回结果给客户端，mysql仍然会返回这个查询的一些信息，如该查询影响到的行数。
  - 如果查询可以被缓存，那么mysql在这个阶段也会将结果放到查询缓存中。
  - mysql将结果集返回客户端是一个增量、逐步返回的过程。这样有两个好处：服务器端无须存储太多的结果，也就不会因为返回太多结果而消耗太多的内存；这样处理也让mysql客户端第一时间获得返回的结果。结果集中的每一行都会以一个满足mysql客户端/服务器通信协议的包发送，再通过tcp协议进行传输，在tcp传输的过程中，可能对mysql的封包进行缓存然后批量传输。





##  MySQL查询优化器

### 基于开销的查询优化器

- MySQL采用了基于开销的优化器，以确定处理查询的最解方式，也就是说执行查询之前，都会先选择一条自以为最优的方案，然后执行这个方案来获取结果。在很多情况下，MySQL能够计算最佳的可能查询计划，但在某些情况下，MySQL没有关于数据的足够信息，或者是提供太多的相关数据信息，估测就不那么友好了。

- MySQL优化器中，一个主要的目标是只要可能就是用索引，而且使用条件最严格的索引来尽可能多、尽可能快地排除那些不符合索引条件的数据行，说白了就是选择怎样使用索引，当然优化器还受其他的影响。

```SQL
CREATE TABLE `t8` (
	`id1` int(11) NOT NULL,
	`id2` int(11) NOT NULL,
	KEY `id1_key` (`id1`),
	KEY `id2_key` (`id2`)
);
insert into t8 values(1,2),(3,4),(1,3),(1,1),(5,0),(1,0);

mysql> select * from t8;
+-----+-----+
| id1 | id2 |
+-----+-----+
|   1 |   2 |
|   3 |   4 |
|   1 |   3 |
|   1 |   1 |
|   5 |   0 |
|   1 |   0 |
+-----+-----+
6 rows in set (0.00 sec)
```

- 分析语句执行计划`select * from t8 where id1=1 and id2=0;`
  - 在执行上述语句中，不会从table中一行一行的比对数据id1和id2。
  - 优化器会先分析数据表，得知有索引id1_key与id2_key
  - 如果先判断id1_key的话，需要从4行数据中排除3行数据；如果先判断id2_key的话，然后需要从2行中排除1行。 
  - 判断id2_key需要较少的计算和磁盘输入输出。因此，查询优化器会规定程序，先去检验id2_key索引，然后在从中挑出id2为0的数据行

```SQL
mysql> explain select * from t8 where id1=1 and id2=0;
+----+-------------+-------+-------------+-----------------+-----------------+---------+------+------+------------------------------------------------------------+
| id | select_type | table | type        | possible_keys   | key             | key_len | ref  | rows | Extra                                                      |
+----+-------------+-------+-------------+-----------------+-----------------+---------+------+------+------------------------------------------------------------+
|  1 | SIMPLE      | t8    | index_merge | id1_key,id2_key | id2_key,id1_key | 4,4     | NULL |    1 | Using intersect(id2_key,id1_key); Using where; Using index |
+----+-------------+-------+-------------+-----------------+-----------------+---------+------+------+------------------------------------------------------------+
1 row in set (0.00 sec)
```



- 分析语句执行计划`select * from t8 where id1=5 and id2=0; `
  - 分析id1=1的行数只有一行，所以优先使用id1_key

```SQL
mysql> explain select * from t8 where id1=5 and id2=0;
+----+-------------+-------+------+-----------------+---------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys   | key     | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+-----------------+---------+---------+-------+------+-------------+
|  1 | SIMPLE      | t8    | ref  | id1_key,id2_key | id1_key | 4       | const |    1 | Using where |
+----+-------------+-------+------+-----------------+---------+---------+-------+------+-------------+
1 row in set (0.00 sec)

```



- 分析复合索引条件下的查询
  - 创建符合索引`ALTER TABLE t8 ADD KEY id1_id2_key(`id1`,`id2`) `;
  - `select * from t8 where id1=1 and id2=0; `
  - id1=1 和 id2=0分别都有多余一行数据，但是同时成立的之后一行，所以，会走复合索引

```SQL
mysql> explain select * from t8 where id1=1 and id2=0;
+----+-------------+-------+------+-----------------------------+-------------+---------+-------------+------+-------------+
| id | select_type | table | type | possible_keys               | key         | key_len | ref         | rows | Extra       |
+----+-------------+-------+------+-----------------------------+-------------+---------+-------------+------+-------------+
|  1 | SIMPLE      | t8    | ref  | id1_key,id2_key,id1_id2_key | id1_id2_key | 8       | const,const |    1 | Using index |
+----+-------------+-------+------+-----------------------------+-------------+---------+-------------+------+-------------+
1 row in set (0.00 sec)
```



###  强制索引

- 通过 `FORCE INDEX (IDX1 [, IND2])` 或者使用 `USE INDEX (IDX1 [,IDX2]) ` 来指定使用哪个索引，也可以指定多个索引，让优化器从中挑选



###  忽略索引

- 可以使用`IGNORE INDEX(索引1[，索引2])`来忽略一些索引，这样优化器，就不会考虑使用这些所有，减少优化器优化时间。



###  **影响优化器使用数据表的顺序**

**影响优化器使用数据表的顺序**

- 一般情况下，MySQL优化器会自行决定按照哪种顺序扫描数据表才能最快地检索出数据，但是我们可以通过`STRAGHT_JOIN`强制优化器按特定的顺序使用数据表，毕竟优化器做的判断不一定都是最优的。
- 使用原则:
  - 让限制最强的选取操作最先执行。
  - STRAIGHT_JOIN可以放在SELECT后面，也可以放在FROM子句中。
  - 例如医生表与医院表连表查询，会把医生表放到前面执行，因为数量更少



###  查询优化器处理的动作

####  常量转化

> 它能够对sql语句中的常量进行转化，比如下面的表达式： WHERE col1 = col2 AND col2 = 'x'; 
>
> 依据传递性：如果A=B and B=C，那么就能得出A=C。所以上面的表达式mysql查询优化器能进行如下的优
>
> 化：WHERE col1 = 'x' AND col2 = 'x'



####  无效代码排除

> 查询优化器会对一些无用的条件进行过滤，比如说 WHERE 0=0 AND column1='y' 因为第一个条件是始终为true的，所以可以移除该条件，变为：WHERE column1='y'再见如下表达式：WHERE (0=1 AND s1=5) OR s1=7因为前一个括号内的表达式始终为false，因此可以移除该表达式，变为：WHERE s1=7
>
> 一些情况下甚至可 以将整个WHERE子句去掉，见下面的表达式：WHERE (0=1 AND s1=5)我们可以看到,WHERE子句始终为FALASE，那么WHERE条件是不可能发生的。当然我们也可以讲，WHERE条件被优化掉了

####  常量计算

> 如下表达式：WHERE col1 = 1 + 2转化为：WHERE col1 = 3 Mysql会对常量表达进行计算，然后将结果生成条件。

####  存储类型

- 当我们评估一个条件表达式，MySQL判断该表达式的存取类型。下面是一些存取类型，按照从最优到最差的顺序进行排列：
  - const 常量表
  - eq_ref unique/primary索引，并且使用的是'='进行存取
  - ref 索引使用'='进行存取
  - ref_or_null 索引使用'='进行存取，并且有可能为NULL
  - range 索引使用BETWEEN、IN、>=、LIKE等进行存取
  - index 索引全扫描
  - ALL 表全扫描
- 优化器根据存取类型选择合适的驱动表达式。





